# ðŸŽ¯ AUTONOMOUS PRINCIPAL ENGINEER - OPERATIONAL DOCTRINE

This document contains the durable, universal principles that govern all development activities in this project. It is a living document, updated automatically at the conclusion of each successful development cycle to incorporate new learnings.

---

## 1. TypeScript & Type Safety

- **Principle 1.1 (No 'any'):** The `any` type is strictly forbidden. All code must be type-safe. Type assertions should be avoided in favor of proper type definitions, guards, and inference.
- **Principle 1.2 (Explicit is Better):** Explicitly type function parameters and return values. Rely on inference for local variables unless clarity demands an explicit type.
- **Principle 1.3 (Established Type Casting Patterns):** When working with Supabase JSON content, always use the established `as unknown as Json` pattern rather than `as any`. Follow existing codebase patterns for type casting to maintain consistency and prevent runtime errors.
- **Principle 1.4 (Structured Data Type Safety):** When creating JSON-LD structured data or complex object mappings, always define proper interfaces instead of using `any` types. This ensures type safety for complex nested structures like MusicEvent schemas and prevents runtime errors in structured data generation.
- **Principle 1.5 (Import Verification):** Always verify that exports exist before attempting imports, especially with complex component files. Use grep searches or IDE navigation to confirm export availability before writing import statements. This prevents build failures and reduces iteration cycles.

---

## 2. Database Interaction Patterns

- **Principle 2.1 (Separation of Read/Write Types):** Recognize that the data shape for reading from the database (e.g., `Gig`) is often different from the shape for writing to it (e.g., `GigInsert`).
- **Principle 2.2 (Insert/Update Type Generation):** For database insert or update operations, create dedicated types using the `Omit<BaseType, 'id' | 'created_at' | ...auto_generated_fields>` pattern. This ensures that client-side code does not attempt to provide values for fields generated by the database.
- **Principle 2.3 (Database Field Mapping):** When mapping database records to component interfaces, always map all relevant fields explicitly, including optional fields. Use conditional mapping (e.g., `field || undefined`) to handle nullable database fields properly. This ensures complete data flow from database to UI components.

---

## 3. Data Transformation & Mapping

- **Principle 3.1 (Explicit Object Construction):** When mapping data from one type to another (e.g., from form values to a database insert object), construct the target object explicitly, field by field. Avoid relying solely on spread syntax (`...`) when types differ, as this can inadvertently include unwanted properties or miss required transformations, leading to type mismatches.
- **Principle 3.2 (Conditional Field Construction):** When building objects with conditional fields (e.g., optional offers, organizer data), use explicit object construction with conditional logic rather than spread syntax. This ensures proper type safety and prevents undefined properties from being included in the final object.

---

## 4. User Interface & Experience

- **Principle 4.1 (Intelligent Input Enhancement):** When implementing custom form inputs with auto-formatting or validation, create explicit event handlers that integrate cleanly with existing form management systems. Use `onChange`, `onBlur`, and `onKeyDown` handlers to provide intelligent input assistance while preserving form library compatibility.
- **Principle 4.2 (Layout Optimization):** Small CSS class adjustments (e.g., `w-full` to `w-fit`) can significantly improve visual hierarchy and user experience. Always consider the visual impact of layout changes on user workflow efficiency.
- **Principle 4.3 (UI Completeness):** When implementing form elements, ensure all visual indicators are included (e.g., required asterisks, consistent labeling). Missing visual cues can confuse users and degrade the overall experience.
- **Principle 4.4 (Component Consistency):** Similar components across the application should maintain consistent labeling, behavior, and visual presentation. This includes terminology, formatting, and interaction patterns.
- **Principle 4.5 (Layout Pattern Recognition):** When refactoring UI layouts, always identify existing successful patterns first and replicate them exactly rather than creating new patterns. This ensures visual consistency and reduces cognitive load for users.
- **Principle 4.6 (Incremental Layout Verification):** Verify layout changes at each step rather than waiting until completion. This prevents compound errors and ensures each modification maintains the intended visual hierarchy.
- **Principle 4.7 (Conditional Validation Alignment):** When form fields are conditionally rendered (hidden/shown based on state), validation schemas must also be conditional to prevent silent validation failures. Use `.superRefine()` or similar conditional validation patterns to ensure validation rules match the actual UI state.
- **Principle 4.8 (Form Layout Optimization):** For complex form fields, prefer single-column layouts over multi-column grids to improve mobile experience and reduce cognitive load. Use appropriate container width constraints (e.g., `max-w-[800px]`) to enhance form readability and user experience.
- **Principle 4.9 (Design System Color Consistency):** Always use consistent design system colors for similar UI elements. Required field indicators, error states, and interactive elements should follow the established color hierarchy to maintain visual consistency and user familiarity.
- **Principle 4.10 (UI Labeling Clarity):** Form labels should clearly indicate their purpose and visibility to end users. Avoid technical jargon and provide context about how the field will be used (e.g., "Alt-teksti (ei nÃ¤y kÃ¤yttÃ¤jille)" instead of just "Alt-teksti"). This prevents user confusion and improves the overall form experience.

---

## 5. Code Quality & Consistency

- **Principle 5.1 (Formatting Consistency):** Maintain consistent code formatting patterns throughout implementations. Use double quotes for string literals, proper line breaks for long function parameters, and consistent spacing to improve code readability and maintainability. Inconsistent formatting creates maintenance burden and user confusion, directly impacting code quality and developer experience.
- **Principle 5.2 (User Feedback Integration):** When users provide corrections or improvements, integrate them immediately as they often reveal subtle but important quality enhancements that improve the overall user experience and code quality.
- **Principle 5.3 (Build Over Linter):** When linter errors persist but builds succeed, prioritize build success as the source of truth for functionality. Linter false positives should not block progress when the build confirms the code is functionally correct.
- **Principle 5.4 (String Handling Precision):** When working with multi-line strings containing quotes or special characters, ensure proper escaping to prevent runtime errors. Use template literals or proper quote escaping techniques to maintain string integrity and prevent parsing issues. Prefer single quotes for better readability when dealing with strings containing double quotes.
- **Principle 5.5 (Variable Scope Vigilance):** Always check for variable name conflicts when creating new variables in functions that interact with existing query data or state. Use descriptive, unique variable names to prevent shadowing and scope confusion. When extending existing functions, audit all variable names to ensure no conflicts with parent scope variables.
- **Principle 5.6 (Build Verification Protocol):** Run build tests after each major change to prevent compound errors and ensure system integrity. Never accumulate multiple changes without intermediate build verification, as this makes error isolation significantly more difficult.
- **Principle 5.7 (Fallback Logic Simplicity):** Keep fallback logic simple and direct rather than overly complex conditional chains. Complex fallback logic is harder to maintain and debug. When displaying data with optional fields, prefer direct property access over complex conditional logic that checks multiple conditions.
- **Principle 5.8 (User Feedback Integration Protocol):** When users provide corrections or improvements, integrate them immediately as they often reveal subtle but important quality enhancements that improve the overall user experience and code quality. User feedback is a critical source of system improvement and should be treated as high-priority input.
- **Principle 5.9 (Code Formatting Vigilance):** Maintain consistent code formatting patterns throughout implementations, especially for multi-line statements, imports, and template literals. Pay special attention to formatting when users provide corrections, as they often reveal important quality enhancements. Inconsistent formatting creates maintenance burden and user confusion, directly impacting code quality and developer experience.
- **Principle 5.10 (Import Statement Standards):** Multi-line imports should follow consistent formatting patterns with proper line breaks and alignment. This improves code readability and maintains consistency across the codebase.
- **Principle 5.11 (Template Literal Formatting):** Long template literals should be properly formatted for readability, using appropriate line breaks and indentation to prevent horizontal scrolling and improve code maintainability.

---

## 6. Form Management & Schema Evolution

- **Principle 6.1 (Form Schema Evolution Safety):** When extending existing form schemas with new fields, ensure the form reset logic, submission handlers, and validation schemas are updated to handle new fields properly. Always audit form data flow from schema definition through form reset, validation, and submission to prevent silent data loss or validation failures.
- **Principle 6.2 (Storage Pattern Consistency):** When implementing file upload functionality, carefully consider whether to use UUID-based filenames (for unique files) or static paths (for overwritable files). Match the pattern to the use case requirements - unique files need UUIDs, while overwritable files (like CVs) should use static paths with upsert options.

---

## 7. React Query & Supabase Integration

- **Principle 7.1 (Local Fetch Function Pattern):** For React Query + Supabase integration, prefer local fetch functions over shared utilities. This provides better encapsulation, clearer data flow, and reduces coupling between components. Each page/component should define its own fetch functions tailored to its specific data needs.
- **Principle 7.2 (Query Key Consistency):** Use consistent query keys across the application for the same data sources. This enables proper cache invalidation and data synchronization between components. Follow a hierarchical naming pattern (e.g., `["videos"]`, `["gigs"]`) for better cache management.

---

## 8. System Analysis & Architecture

- **Principle 8.1 (Complete System Analysis):** When implementing features that affect data ordering, sequencing, or state management, analyze ALL CRUD operations that could impact that ordering. Don't implement UI features in isolation - ensure the underlying data operations maintain integrity across Create, Read, Update, and Delete operations.
- **Principle 8.2 (Data Integrity First):** Before implementing UI features that manipulate data ordering, ensure all database operations maintain data integrity. This includes proper index management, gap-free sequences, and consistent state across all operations.
- **Principle 8.3 (User Feedback Integration):** User corrections often reveal critical gaps in system analysis. When users provide feedback that corrects your approach, integrate it immediately and learn from it to prevent similar oversights in future implementations.
- **Principle 8.4 (External API Verification):** Before implementing features that depend on external library capabilities, verify the actual API surface through documentation or testing. Never assume external APIs support specific features without verification, as this leads to implementation dead-ends and wasted effort.
- **Principle 8.5 (Pattern Replication Over Innovation):** When similar functionality already exists in the codebase, replicate the proven pattern exactly rather than creating new approaches. This ensures consistency, reduces bugs, and leverages battle-tested implementations.
- **Principle 8.6 (Migration Dependency Verification):** Before implementing features that require database migrations, verify that the migration system is properly configured and linked. Check migration dependencies early in the process to prevent deployment blockers and ensure smooth database schema evolution.
- **Principle 8.7 (Code Formatting Vigilance):** Maintain consistent code formatting patterns throughout implementations, especially for complex form layouts and multi-line parameters. Inconsistent formatting creates maintenance burden and user confusion, directly impacting code quality and developer experience. Pay special attention to formatting when users provide corrections, as they often reveal important quality enhancements.
- **Principle 8.8 (System-Wide Impact Analysis):** When modifying shared components or data structures, always identify and check ALL consumers of the changed component. Use grep searches to verify no other components are affected. This prevents regressions and ensures system-wide consistency.
