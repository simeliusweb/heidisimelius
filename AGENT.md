# ðŸŽ¯ AUTONOMOUS PRINCIPAL ENGINEER - OPERATIONAL DOCTRINE

This document contains the durable, universal principles that govern all development activities in this project. It is a living document, updated automatically at the conclusion of each successful development cycle to incorporate new learnings.

---

## 1. TypeScript & Type Safety

- **Principle 1.1 (No 'any'):** The `any` type is strictly forbidden. All code must be type-safe. Type assertions should be avoided in favor of proper type definitions, guards, and inference.
- **Principle 1.2 (Explicit is Better):** Explicitly type function parameters and return values. Rely on inference for local variables unless clarity demands an explicit type.

---

## 2. Database Interaction Patterns

- **Principle 2.1 (Separation of Read/Write Types):** Recognize that the data shape for reading from the database (e.g., `Gig`) is often different from the shape for writing to it (e.g., `GigInsert`).
- **Principle 2.2 (Insert/Update Type Generation):** For database insert or update operations, create dedicated types using the `Omit<BaseType, 'id' | 'created_at' | ...auto_generated_fields>` pattern. This ensures that client-side code does not attempt to provide values for fields generated by the database.

---

## 3. Data Transformation & Mapping

- **Principle 3.1 (Explicit Object Construction):** When mapping data from one type to another (e.g., from form values to a database insert object), construct the target object explicitly, field by field. Avoid relying solely on spread syntax (`...`) when types differ, as this can inadvertently include unwanted properties or miss required transformations, leading to type mismatches.

---

## 4. User Interface & Experience

- **Principle 4.1 (Intelligent Input Enhancement):** When implementing custom form inputs with auto-formatting or validation, create explicit event handlers that integrate cleanly with existing form management systems. Use `onChange`, `onBlur`, and `onKeyDown` handlers to provide intelligent input assistance while preserving form library compatibility.
- **Principle 4.2 (Layout Optimization):** Small CSS class adjustments (e.g., `w-full` to `w-fit`) can significantly improve visual hierarchy and user experience. Always consider the visual impact of layout changes on user workflow efficiency.
- **Principle 4.3 (UI Completeness):** When implementing form elements, ensure all visual indicators are included (e.g., required asterisks, consistent labeling). Missing visual cues can confuse users and degrade the overall experience.
- **Principle 4.4 (Component Consistency):** Similar components across the application should maintain consistent labeling, behavior, and visual presentation. This includes terminology, formatting, and interaction patterns.
- **Principle 4.5 (Layout Pattern Recognition):** When refactoring UI layouts, always identify existing successful patterns first and replicate them exactly rather than creating new patterns. This ensures visual consistency and reduces cognitive load for users.
- **Principle 4.6 (Incremental Layout Verification):** Verify layout changes at each step rather than waiting until completion. This prevents compound errors and ensures each modification maintains the intended visual hierarchy.
- **Principle 4.7 (Conditional Validation Alignment):** When form fields are conditionally rendered (hidden/shown based on state), validation schemas must also be conditional to prevent silent validation failures. Use `.superRefine()` or similar conditional validation patterns to ensure validation rules match the actual UI state.
- **Principle 4.8 (Form Layout Optimization):** For complex form fields, prefer single-column layouts over multi-column grids to improve mobile experience and reduce cognitive load. Use appropriate container width constraints (e.g., `max-w-[800px]`) to enhance form readability and user experience.
- **Principle 4.9 (Design System Color Consistency):** Always use consistent design system colors for similar UI elements. Required field indicators, error states, and interactive elements should follow the established color hierarchy to maintain visual consistency and user familiarity.

---

## 5. Code Quality & Consistency

- **Principle 5.1 (Formatting Consistency):** Maintain consistent code formatting patterns throughout implementations. Use double quotes for string literals, proper line breaks for long function parameters, and consistent spacing to improve code readability and maintainability. Inconsistent formatting creates maintenance burden and user confusion, directly impacting code quality and developer experience.
- **Principle 5.2 (User Feedback Integration):** When users provide corrections or improvements, integrate them immediately as they often reveal subtle but important quality enhancements that improve the overall user experience and code quality.
- **Principle 5.3 (Build Over Linter):** When linter errors persist but builds succeed, prioritize build success as the source of truth for functionality. Linter false positives should not block progress when the build confirms the code is functionally correct.
- **Principle 5.4 (String Handling Precision):** When working with multi-line strings containing quotes or special characters, ensure proper escaping to prevent runtime errors. Use template literals or proper quote escaping techniques to maintain string integrity and prevent parsing issues.

---

## 6. System Analysis & Architecture

- **Principle 6.1 (Complete System Analysis):** When implementing features that affect data ordering, sequencing, or state management, analyze ALL CRUD operations that could impact that ordering. Don't implement UI features in isolation - ensure the underlying data operations maintain integrity across Create, Read, Update, and Delete operations.
- **Principle 6.2 (Data Integrity First):** Before implementing UI features that manipulate data ordering, ensure all database operations maintain data integrity. This includes proper index management, gap-free sequences, and consistent state across all operations.
- **Principle 6.3 (User Feedback Integration):** User corrections often reveal critical gaps in system analysis. When users provide feedback that corrects your approach, integrate it immediately and learn from it to prevent similar oversights in future implementations.
- **Principle 6.4 (External API Verification):** Before implementing features that depend on external library capabilities, verify the actual API surface through documentation or testing. Never assume external APIs support specific features without verification, as this leads to implementation dead-ends and wasted effort.
- **Principle 6.5 (Pattern Replication Over Innovation):** When similar functionality already exists in the codebase, replicate the proven pattern exactly rather than creating new approaches. This ensures consistency, reduces bugs, and leverages battle-tested implementations.
